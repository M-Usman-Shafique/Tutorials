NEXT vs. REACT:
- More Features: Routing, Image & Font Optimization, Middleware, SSR, Backend etc.
- SSR vs. CSR
- Fast & SEO

PRE-RENDERING: Execution of code on the server side in advance of sending it to the browser.
Execution: converting JS code into HTML.
TYPES:
1. SSG: Code execution on build-time. Used for static data, when data has not to be changed.
Benefits:
a. Fast Loading Experience
b. SEO
2. SSR: Code execution on the server on the request of user before sending it to the user. Used for dynamic data, when data has to be changed.


SSR: When a user sends a webpage request, the server executes the JS code, pre-renders the content & then sends the pre-rendered HTML file & minimal JS to the user which leads to the page loading faster because now browser has lesser JS code to execute & rerender the page.
CSR: Executing the code on user's browser as server sends HTML, CSS & JS code to the client whenever he requests for a webpage. Then browser downloads & executes the JS code which leads to the rerendering of components & finally webpage is displayed.
SEO is very poor in React because search engine searches for sementics/keywords in HTML file, while in React, HTML file has only one (div tag) root element.
DX in React is Good.
But compromises UX & SEO.
Hydration: Attaching event listeners to the elements to make them interactable.
By default every component in app folder goes for SSR.
To enable CSR, add 'use client' on the top.
A SSR component nested inside CSR component will behave as CSR component.
Making the parent component client, make all its child (imported) components client.

Browser-only APIs: setTimeout() & setInterval() etc.
Interactivity, event listeners (onClick, onChange etc.), useState, useEffect, useReducer & custom hooks & which are dependent on these three hooks & react class components are always used as CSR.
layout.js file jis folder mein hogi, layout.js file k tmam features uss folder k har component mein show hongy like navbar, footer etc.
Data Fetching:
1. SSR (dynamic): Data will be fetched but not cached/stored.
Limitation: What if 1M pages?
2. Static Site Generation (static/default): on build app pages cached by CDN, indexed by search engine & serve instantly.
Limitation: What if data changes after build?
3. Incremental Static Regeneration (static+dynamic): Data will be cached but after sometimes it will be refreshed: { next: { revalidate: 10 }}
Note: Diff. between SSR & SSG can only be understood when we are in production (build) mode, otherwise in development mode we see no difference.

NESTED Routes:
GROUP ROUTE:
DYNAMIC ROUTE:
CATCH ALL ROUTE:


For images use <Image/> instead of <img>
External styling cannot be used in Nest.JS except by importing in layout.js file where it will be available globally.
Modular Styling: custom.module.css => file name || main => class name
Usage: className={custom.main}




Client Side Data Fetching:
1st. we loads our app on client
2nd. app make API call
3rd. Wait for data
4th. Set the received data in state
5th. Rerender the component to show that data.
SWR (Stale While Revalidation): Optimization of fetching by Next.JS

Server Side Data Fetching:
1st: Fetch data on server
2nd: Render our page on server
3rd: Display the rendered page to the user with data on it.

Folder Structure:
middleware.js: Todo a task after sending API request & before implementing the response on webpage.
Any folder 0r file inside src/app is related to the app router.
layout.js = index.html (common/shared UI)
page.js = index.js (Homepage & unique UI)

REST API vs. GraphQL:
1. Over fetching of data in case of a single entity i.e. Post.
2. Under fetching pf data in case of multiple entities i.e. Post & its commments.
3. REST API: GET, POST, PUT, DELETE vs. GraphQL: POST


GraphQL:
1. Query: Get Data
2. Mutation: Post, Update, Delete Data
3. Resolver: Logic to handle query & Mutation

comment.js
graphqlRequest.js
commentForm.js
parentIn: null

ROUTING:
1. Linking: <Link href="/about">About</Link>
2. Navigation:
const router = useRouter();
const handleNavigation = (route) => {
router.push(route);
}
<button onClick={()=> handleNavigation("/about")}>About</button>